引用<br/>
[CERT セキュアコーディングスタンダード](https://www.jpcert.or.jp/sc-rules/ "https://www.jpcert.or.jp/sc-rules/")<br/>
<br/>

<details><summary>01 プリプロセッサ (PRE)</summary><div>

## レコメンデーション

PRE00-C	関数形式マクロよりもインライン関数やスタティック関数を使う <br/>
PRE01-C	マクロ内の引数名は括弧で囲む <br/>
PRE02-C	マクロ置換リストは括弧で囲む <br/>
PRE03-C	ポインタ型でない型をエンコードするには define よりも typedef を選ぶ <br/>
PRE04-C	標準ヘッダファイル名を再利用しない <br/>
PRE05-C	字句の結合や文字列化を行う際のマクロ置換動作をよく理解する <br/>
PRE06-C	ヘッダファイルはインクルードガードで囲む <br/>
PRE07-C	"??" の繰り返しは避ける <br/>
PRE08-C	ヘッダファイル名が一意であることを保証する <br/>
PRE09-C	セキュアな関数を非推奨関数や時代遅れの関数に置き換えない <br/>
PRE10-C	複数の文からなるマクロは do-while ループで包む <br/>
PRE11-C	マクロ定義をセミコロンで終端しない <br/>
PRE12-C	安全でないマクロを定義しない <br/>
PRE13-C	あらかじめ定義された標準マクロで準拠規格やバージョンを確認する <br/>

## ルール

PRE30-C	文字列連結によってユニバーサル文字名を作成しない <br/>
PRE31-C	安全でないマクロの引数では副作用を避ける <br/>
PRE32-C	関数形式マクロの呼出しのなかで前処理指令を使用しない <br/>

</div></details>

<details><summary>02 宣言と初期化 (DCL)</summary><div>

## レコメンデーション

DCL00-C	不変(immutable)オブジェクトは const 修飾する <br/>
DCL01-C	サブスコープで変数名を再利用しない <br/>
DCL02-C	視覚的に区別できる識別子を使う <br/>
DCL03-C	定数式の値をテストするには静的アサートを使う <br/>
DCL04-C	ひとつの宣言で2つ以上の変数を宣言しない <br/>
DCL05-C	typedef による型定義ではポインタ型を避ける <br/>
DCL06-C	リテラル値の表現には意味のあるシンボル定数を使う <br/>
DCL07-C	関数宣言子には適切な型情報を含める <br/>
DCL08-C	定数定義間の関係は適切にコード化する <br/>
DCL09-C	errno を返す関数は返り値を errno_t 型として定義する <br/>
DCL10-C	可変引数関数の作成者と利用者の間の取り決めを維持する <br/>
DCL11-C	可変引数関数に関連する型問題について理解する <br/>
DCL12-C	抽象データ型は opaque な型を使って実装する <br/>
DCL13-C	関数の引数が関数自身によって変更されない値を参照するポインタならば、関数の引数をconstとして宣言する <br/>
DCL15-C	外部結合を必要としないファイル有効範囲のオブジェクトや関数は static 宣言する <br/>
DCL16-C	long 値を表すには小文字の "l" ではなく大文字の "L" を使う <br/>
DCL17-C	volatile 修飾された変数が間違ってコンパイルされることに注意 <br/>
DCL18-C	10 進値を指定するとき、整数定数を 0 で始めない <br/>
DCL19-C	変数と関数の有効範囲を最小限にする <br/>
DCL20-C	引数を受け付けない関数の場合も必ず void を指定する <br/>
DCL21-C	複合リテラルの記憶域を理解する <br/>
DCL22-C	キャッシュできないデータには volatile を使う <br/>
DCL23-C	相互に可視である識別子が一意であることを保証する <br/>

## ルール

DCL30-C	適切な記憶域期間でオブジェクトを宣言する <br/>
DCL31-C	識別子は宣言してから使用する <br/>
DCL36-C	矛盾する結合の種類を使用して識別子を宣言しない <br/>
DCL37-C	予約済み識別子の宣言や定義をしない <br/>
DCL38-C	フレキシブル配列メンバには正しい構文を使用する <br/>
DCL39-C	信頼境界を越えて構造体を渡すとき情報漏えいしない <br/>
DCL40-C	同一の関数やオブジェクトに対して適合(compatible)しない宣言をしない <br/>
DCL41-C	switch 文のなかでは最初の case 句より前で変数宣言しない <br/>

</div></details>

<details><summary>03 式 (EXP)</summary><div>

## レコメンデーション

EXP00-C	括弧を使用して演算の優先順位を指定する <br/>
EXP01-C	ポインタが参照する型のサイズを求めるのにポインタのサイズを使わない <br/>
EXP02-C	論理 AND 演算子および論理 OR 演算子のショートサーキット動作について注意する <br/>
EXP03-C	構造体のサイズが構造体のメンバのサイズの和に等しいと決めてかからない <br/>
EXP04-C	構造体を含むバイト単位の比較を行わない <br/>
EXP05-C	const 修飾をキャストではずさない <br/>
EXP07-C	式中で、定数の値を仮定して定数を使うメリットを損なわない <br/>
EXP08-C	ポインタ演算は正しく使用する <br/>
EXP09-C	型や変数のサイズは sizeof を使って求める <br/>
EXP10-C	部分式の評価順序や副作用の発生順序に依存しない <br/>
EXP11-C	ビットフィールド構造体のレイアウトについて勝手な想定をしない <br/>
EXP12-C	関数の返り値を無視しない <br/>
EXP13-C	関係演算子および等価演算子は、結合則が成り立たないものとして扱う <br/>
EXP14-C	char 型や short 型の値に対してビット単位の演算を行う際には整数拡張(integer promotion)が行われることに注意 <br/>
EXP15-C	if、for、while 文と同じ行にセミコロンを使用しない <br/>
EXP16-C	関数ポインタを定数値と比較しない <br/>
EXP17-C	条件式に対してビット単位の演算を行わない <br/>
EXP19-C	if、for、while 文の本体は波括弧で囲む <br/>
EXP20-C	成功、真偽、等価を判定するには明示的な検査を行う <br/>
EXP21-C	等価比較の左側に定数を配置する <br/>

## ルール

EXP30-C	副作用が発生する式の評価順序に依存しない <br/>
EXP31-C	assert() のなかでは副作用を避ける <br/>
EXP32-C	非 volatile 参照により volatile オブジェクトにアクセスしない <br/>
EXP33-C	初期化されていないメモリからの読み込みを行わない <br/>
EXP34-C	null ポインタを参照しない <br/>
EXP35-C	一時的な生存期間を持つオブジェクトを変更しない <br/>
EXP36-C	ポインタをより厳密にアラインされるポインタ型に変換しない <br/>
EXP37-C	正しい引数の数と型で関数を呼び出す <br/>
EXP38-C	ビットフィールドメンバや無効な型で offsetof() を呼び出さない <br/>
EXP39-C	適合しない型のポインタを使って変数にアクセスしない <br/>
EXP40-C	定数オブジェクトを変更しない <br/>
EXP44-C	sizeof 演算子のオペランドは副作用を持たせない <br/>
EXP45-C	選択文に対して代入を行わない <br/>

</div></details>

<details><summary>04 整数 (INT)</summary><div>

## レコメンデーション

INT00-C	処理系のデータモデルについて理解する <br/>
INT01-C	オブジェクトのサイズを表現するすべての整数値に rsize_t もしくは size_t を使用する <br/>
INT02-C	整数変換のルールを理解する <br/>
INT04-C	信頼できない入力源から取得した整数値は制限する <br/>
INT05-C	可能性のあるすべての入力を処理できない入力関数を使って文字データを変換しない <br/>
INT06-C	文字列トークンを整数に変換するには strtol() 系の関数を使う <br/>
INT07-C	数値には符号の有無を明示した char 型のみを使用する <br/>
INT08-C	すべての整数値が範囲内にあることを確認する <br/>
INT09-C	列挙定数が一意の値に対応することを保証する <br/>
INT10-C	% 演算子を使用する際、結果の剰余が正であると想定しない <br/>
INT12-C	式中で使用される単なるintのビットフィールドの型について勝手な想定をしない <br/>
INT13-C	ビット単位の演算子は符号無しオペランドに対してのみ使用する <br/>
INT14-C	同じデータに対してビット単位の演算と算術演算を行わない <br/>
INT15-C	プログラマ定義の整数型に対する書式付き入出力には、intmax_t もしくは uintmax_t を使用する <br/>
INT16-C	符号付き整数の表現形式について勝手な想定をしない <br/>
INT17-C	処理系に依存しない方法で整数定数を定義する <br/>
INT18-C	より大きいサイズの整数との比較や代入を行う前に、整数式をそのサイズで評価する <br/>

## ルール

INT30-C	符号無し整数の演算結果がラップアラウンドしないようにする <br/>
INT31-C	整数変換によってデータの消失や解釈間違いが発生しないことを保証する <br/>
INT32-C	符号付き整数演算がオーバーフローを引き起こさないことを保証する <br/>
INT33-C	除算および剰余演算がゼロ除算エラーを引き起こさないことを保証する <br/>
INT34-C	負のビット数のシフトやオペランドのビット数以上のシフトを行わない <br/>
INT35-C	整数型の精度を正しく求める <br/>
INT36-C	ポインタから整数への変換、整数からポインタへの変換 <br/>

</div></details>


<details><summary>05 浮動小数点 (FLP)</summary><div>

## レコメンデーション

FLP00-C	浮動小数点数の限界を理解する <br/>
FLP01-C	浮動小数点式の演算の順序に注意する <br/>
FLP02-C	精度の高い計算が必要な場合は浮動小数点数の使用を避ける <br/>
FLP03-C	浮動小数点エラーを検知して処理する <br/>
FLP04-C	浮動小数点入力が例外値でないか検査する <br/>
FLP05-C	非正規化数を使用しない <br/>
FLP06-C	浮動小数点数の演算時には整数を浮動小数点数に変換する <br/>
FLP07-C	浮動小数点型を返す関数の返り値はキャストする

## ルール

FLP30-C	浮動小数点変数をループカウンタに使用しない <br/>
FLP32-C	数学関数における定義域エラーおよび値域エラーを防止または検出する <br/>
FLP34-C	浮動小数点の型変換は変換後の型の範囲に収まるようにする <br/>
FLP36-C	整数型から浮動小数点型への変換時に精度を確保する <br/>
FLP37-C	浮動小数点値の比較にオブジェクト表現を使用しない <br/>

</div></details>

<details><summary>06 配列 (ARR)</summary><div>

## レコメンデーション

ARR00-C	配列の仕組みを理解する <br/>
ARR01-C	配列のサイズを求めるときに sizeof 演算子をポインタに適用しない <br/>
ARR02-C	初期化子が暗黙的にサイズを定義する場合であっても、配列のサイズは明示的に指定する <br/>

## ルール

ARR30-C	境界外を指すポインタや配列添字を生成したり使用したりしない <br/>
ARR31-C	すべてのソースファイルで一貫した配列表記を用いる <br/>
ARR32-C	可変長配列のサイズ引数は適切な範囲内にあることを保証する <br/>
ARR33-C	コピーは必ず十分なサイズの記憶領域に対して行われることを保証する <br/>
ARR34-C	式中の配列の型は適合していることを保証する <br/>
ARR36-C	異なる配列を指す2つのポインタに対して減算や比較を行わない <br/>
ARR37-C	配列以外のオブジェクトを指すポインタに対して整数の加算や減算を行わない <br/>
ARR38-C	ライブラリ関数が無効なポインタを生成しないことを保証する <br/>

</div></details>

<details><summary>07 文字と文字列 (STR)</summary><div>

## レコメンデーション

STR00-C	文字の表現には適切な型を使用する <br/>
STR01-C	文字列の管理は一貫した方法で行う <br/>
STR02-C	複雑なサブシステムに渡すデータは無害化する <br/>
STR03-C	null 終端バイト文字列を不注意に切り捨てない <br/>
STR04-C	基本文字集合にある文字を表すには単なる char を使用する <br/>
STR05-C	文字列リテラルの参照には const へのポインタを使用する <br/>
STR06-C	strtok() が分割対象文字列を変更しないと想定しない <br/>
STR07-C	境界チェックインタフェースを使用し、文字列操作を行う既存のコードの脅威を緩和する <br/>
STR08-C	新たに開発する文字列処理するコードには managed string を使用する <br/>
STR09-C	単なる文字型の式に対して数値を想定しない <br/>
STR10-C	型が異なる文字列リテラルを結合しない <br/>
STR11-C	文字列リテラルで初期化される文字配列のサイズを指定しない <br/>

## ルール

STR30-C	文字列リテラルを変更しない <br/>
STR31-C	文字データと null 終端文字を格納するために十分な領域を確保する <br/>
STR32-C	文字列を引数にとるライブラリ関数に null 終端されていない文字配列を渡さない <br/>
STR33-C	ワイド文字の文字列サイズは正しく求める <br/>
STR34-C	文字データをより大きなサイズの整数型に変換するときは事前に unsigned char 型に変換する <br/>
STR35-C	長さに制限のないデータを固定長配列へコピーしない <br/>
STR37-C	文字処理関数への引数は unsigned char として表現できなければならない <br/>
STR38-C	ナロー文字列に対するワイド文字関数の使用、およびその逆を避ける <br/>

</div></details>

<details><summary>08 メモリ管理 (MEM)</summary><div>

## レコメンデーション

MEM00-C	メモリの割り当てと解放は、同じ翻訳単位内の同一抽象レベルで行う <br/>
MEM01-C	free() した直後のポインタには新しい値を代入する <br/>
MEM02-C	メモリ割り当て関数の結果は、割り当てた型へのポインタに即座にキャストする <br/>
MEM03-C	再利用可能なリソースに格納された機密情報は消去する <br/>
MEM04-C	サイズ 0 のメモリ割り当てを行わない <br/>
MEM05-C	スタック上で大きなサイズの割り当てを行わない <br/>
MEM06-C	機密情報はディスクに書き出さない <br/>
MEM07-C	calloc() の引数は乗算した結果がラップアラウンドしないようにする <br/>
MEM08-C	realloc() は動的に割り当てられた配列のサイズ変更にのみ使用する <br/>
MEM09-C	メモリ割り当て関数がメモリを初期化すると仮定しない <br/>
MEM10-C	ポインタ検証関数を定義して使用する <br/>
MEM11-C	ヒープ領域が無限にあると想定しない <br/>
MEM12-C	リソースの使用および解放の最中に発生するエラーが原因で関数を終了する場合に、Goto 連鎖の使用を検討する <br/>

## ルール

MEM30-C	解放済みメモリにアクセスしない <br/>
MEM31-C	動的に割り当てられたメモリは一度だけ解放する <br/>
MEM32-C	メモリ割り当てエラーを検出し、対処する <br/>
MEM33-C	フレキシブル配列メンバを含む構造を動的に割り当ててコピーする <br/>
MEM34-C	動的に割り当てられたメモリのみを解放する <br/>
MEM35-C	オブジェクトに対して十分なメモリを割り当てる <br/>
MEM36-C	realloc() 関数呼び出しでオブジェクトのアラインメントを変更しない <br/>

</div></details>

<details><summary>09 入出力 (FIO)</summary><div>

## レコメンデーション

FIO01-C	ファイル名を使用してファイルを識別する関数の使用に注意する <br/>
FIO02-C	汚染された情報源から取得したパス名は正規化する <br/>
FIO03-C	fopen() やファイル作成時の動作について勝手な想定をしない <br/>
FIO04-C	入出力エラーを検出し、処理する <br/>
FIO05-C	複数のファイル属性を使用してファイルを特定する <br/>
FIO06-C	適切なパーミッションを持つファイルを作成する <br/>
FIO07-C	rewind() ではなく fseek() を使用する <br/>
FIO08-C	オープンしたままのファイルに対する remove() の呼び出しに注意する <br/>
FIO09-C	システム間でのバイナリデータ転送に注意する <br/>
FIO10-C	rename() 関数の使用に注意する <br/>
FIO11-C	fopen() のモード引数の指定は慎重に行う <br/>
FIO12-C	setbuf() ではなく setvbuf() を使用する <br/>
FIO13-C	読み取った一文字以外は押し戻さない <br/>
FIO14-C	ファイルストリームにおけるテキストモードとバイナリモードの違いを理解する <br/>
FIO15-C	ファイル操作はセキュアディレクトリで行う <br/>
FIO16-C	ジェイル(監獄)を作成してファイルへのアクセスを制限する <br/>
FIO17-C	fread() を使用するときは、null 終端文字に依存しない <br/>
FIO18-C	fwrite() が書き込み操作を null 文字で終了すると想定しない <br/>
FIO19-C	ファイルサイズの計算に fseek() および ftell() を使用しない <br/>
FIO21-C	一時ファイルを共有ディレクトリに作成しない <br/>
FIO22-C	プロセスを生成する前にファイルをクローズする <br/>
FIO24-C	すでにオープンされているファイルをオープンしない <br/>

## ルール

FIO30-C	ユーザからの入力を使って書式指定文字列を組み立てない <br/>
FIO32-C	通常ファイルに対してのみ行われるべき操作をデバイスファイルに対して行わない <br/>
FIO34-C	ファイルから読み込んだ文字と EOF や WEOF を区別する <br/>
FIO36-C	fgets() が改行文字を読み取ると仮定しない <br/>
FIO37-C	fgets() や fgetws() が読み取り成功時に空でない文字列を返すと想定しない <br/>
FIO38-C	入出力操作に FIlE オブジェクトのコピーを使用しない <br/>
FIO39-C	fflush 関数やファイル位置付け関数を呼び出さずにストリームへの入出力を交互に行わない <br/>
FIO40-C	fgets() が失敗したときは引数に渡した配列の内容をリセットする <br/>
FIO41-C	副作用を持つストリーム引数を getc() または putc() に渡さない <br/>
FIO42-C	使う必要がなくなったファイルはクローズする <br/>
FIO44-C	fsetpos() には fgetpos() が返す値を使用する <br/>
FIO47-C	書式指定文字列を正しく使う <br/>

</div></details>

<details><summary>10 環境 (ENV)</summary><div>

## レコメンデーション

ENV01-C	環境変数のサイズについて勝手な想定をしない <br/>
ENV02-C	同じ名前の複数の環境変数に注意する <br/>
ENV03-C	外部プログラムを呼び出す際は環境を無害化する <br/>

## ルール

ENV30-C	関数の返り値によって参照されるオブジェクトを変更しない <br/>
ENV31-C	環境変数へのポインタを無効にするかもしれない操作の後で、そのポインタを参照しない <br/>
ENV32-C	atexit で登録したハンドラ関数は必ず return する <br/>
ENV33-C	コマンドプロセッサが必要ない場合は system() を呼び出さない <br/>
ENV34-C	getenv() が返す文字列へのポインタを保存しない <br/>

</div></details>

<details><summary>11 シグナル (SIG)</summary><div>

## レコメンデーション

SIG00-C	割り込み不可能なシグナルハンドラによって処理されるシグナルをマスクする <br/>
SIG01-C	シグナルハンドラの継続性に関して処理系定義の詳細を理解する <br/>
SIG02-C	標準的な機能を実装する際はシグナルの使用を避ける <br/>

## ルール

SIG30-C	シグナルハンドラ内では非同期安全な関数のみを呼び出す <br/>
SIG31-C	シグナルハンドラ内で共有オブジェクトにアクセスしない <br/>
SIG32-C	シグナルハンドラ内からlongjmp() を呼び出さない <br/>
SIG33-C	raise() 関数を再帰的に呼び出さない <br/>
SIG34-C	割り込み可能なシグナルハンドラ内から signal() を呼び出さない <br/>
SIG35-C	シグナルハンドラ SIGSEGV、SIGILL、SIGFPE から復帰しない <br/>

</div></details>

<details><summary>12 エラー処理 (ERR)</summary><div>

## レコメンデーション

ERR00-C	エラー処理には一貫性のある方針を採用する <br/>
ERR01-C	errno ではなく ferror() を使って FILE ストリームエラーを検査する <br/>
ERR02-C	正常終了時の値とエラーの値は別の手段で通知する <br/>
ERR03-C	境界チェックインタフェースを呼び出す際は、実行時制約ハンドラを使用する <br/>
ERR04-C	プログラムの適切な終了方法を選択する <br/>
ERR05-C	アプリケーション非依存なコードではエラー検知のみ行ない、エラー処理は行わない <br/>
ERR06-C	assert() と abort() の終了動作を理解する <br/>
ERR07-C	よりよいエラー検査を行える関数を使用する <br/>

## ルール

ERR30-C	関数を呼び出す前に errno をゼロに初期化し、関数の異常終了時にのみ errno を参照する <br/>
ERR31-C	errno を再定義しない <br/>
ERR32-C	errno の未規定の値を参照しない <br/>
ERR33-C	標準ライブラリ関数のエラーを検出し対処する <br/>

</div></details>

<details><summary>13 Application Programing Interface (API)</summary><div>

## レコメンデーション

API00-C	関数のなかで引数を検証する <br/>
API02-C	配列の読み書きを行う関数はコピー元やコピー先のサイズを指定する引数を取れ <br/>
API03-C	関連する関数にはインタフェースと機能に一貫性を持たせる <br/>
API04-C	一貫性があり使いやすいエラー検査方法を提供する <br/>
API07-C	型の安全性を徹底する <br/>
API08-C	関数プロトタイプでは引数に名前をつけない <br/>
API09-C	互換性のある値には同じ型を使用する <br/>

## ルール

</div></details>

<details><summary>14 並列性 (CON)</summary><div>

## レコメンデーション

CON00-C	複数のスレッドによる競合状態を避ける <br/>
CON01-C	同期用プリミティブの取得と解放は、同じ翻訳単位内の同一抽象レベルで行う <br/>
CON02-C	volatile を同期用プリミティブとして使用しない <br/>
CON04-C	終了ステータスが重要でないスレッドでも、join または detach する <br/>
CON05-C	ロックを保持している状態ではブロックする可能性がある操作を行わない <br/>
CON09-C	ロックフリープログラミングの手法を使うときは ABA 問題を避ける <br/>

## ルール

CON30-C	スレッド固有のメモリを適切に解放する <br/>
CON31-C	他のスレッドのミューテックスをアンロックしたり破壊したりしない <br/>
CON32-C	複数スレッドによる隣接データへのアクセスが必要な場合データ競合を防止する <br/>
CON33-C	ライブラリ関数の使用時は競合状態を避ける <br/>
CON34-C	スレッド間で共有されるオブジェクトは適切な記憶域期間を持つように宣言する <br/>
CON35-C	あらかじめ定義した順番でロックしてデッドロックを防ぐ <br/>
CON37-C	マルチスレッドプログラムで signal() を呼び出さない <br/>
CON38-C	1 つのスレッドではなく条件変数を待っているすべてのスレッドに通知する <br/>

</div></details>

<details><summary>49 雑則 (MSC)</summary><div>

## レコメンデーション

MSC00-C	高い警告レベルでのコンパイルで警告が出ないようにする <br/>
MSC01-C	論理的な完全性を追求する <br/>
MSC04-C	コメントの記法には一貫性を持たせ読みやすくする <br/>
MSC05-C	time_t 型の値を直接操作しない <br/>
MSC06-C	コンパイラの最適化に注意する <br/>
MSC07-C	デッドコードを検出して削除する <br/>
MSC09-C	文字の符号化 - 安全対策のために ASCII のサブセットを使用する <br/>
MSC10-C	文字の符号化 - UTF8 に関連する問題 <br/>
MSC11-C	診断テストはアサートを使って組み込む <br/>
MSC12-C	プログラムに対して作用しないコードを検出して削除する <br/>
MSC13-C	使用されない値を検出して削除する <br/>
MSC14-C	必要もなくコードをプラットフォーム依存にしない <br/>
MSC15-C	未定義の動作に依存しない <br/>
MSC16-C	関数ポインタの暗号化を検討する <br/>
MSC17-C	case 句に関連付けられた一連の文は break 文で終了する <br/>
MSC18-C	プログラムコードの中でパスワードなどの機密情報を扱うときは注意する <br/>
MSC19-C	配列を返す関数は、NULL 値ではなく空の配列を返すこと <br/>
MSC20-C	複雑なブロックに制御を渡す際に switch 文を使用しない <br/>
MSC21-C	ループの終了条件には不等式を用いる <br/>
MSC22-C	setjmp()、longjmp() の機能を安全に使用する <br/>
MSC24-C	非推奨関数や時代遅れの関数を使用しない <br/>

## ルール

MSC30-C	疑似乱数の生成に rand() 関数を使用しない <br/>
MSC31-C	関数の返り値は必ず適切な型と比較する <br/>
MSC32-C	乱数生成器には適切なシード値を与える <br/>
MSC33-C	無効なデータを asctime() 関数に渡さない <br/>
MSC37-C	非 void 型関数の制御が関数定義の最終行に到達しないことを保証する <br/>
MSC38-C	マクロとして実装されている可能性のある定義済みの識別子をオブジェクトとして扱わない <br/>
MSC39-C	値が不定の va_list に対して va_arg() を呼び出さない <br/>

</div></details>










<details><summary>50 POSIX (POS)</summary><div>

## レコメンデーション

POS01-C	ファイルを操作するときにはリンクかどうかを確認する <br/>
POS02-C	最小権限の原則に従う <br/>
POS03-C	volatile を同期用プリミティブとして使用しない <br/>
POS04-C	PTHREAD_MUTEX_NORMAL ミューテックスロックの使用を避ける <br/>

## ルール

POS30-C	readlink() 関数を適切に使用する <br/>
POS33-C	vfork() を使用しない <br/>
POS34-C	putenv()の引数として自動変数へのポインタを渡さない <br/>
POS35-C	シンボリックリンクの存在をチェックするときには競合状態を避ける <br/>
POS36-C	権限は正しい順序で破棄する <br/>
POS37-C	権限の破棄は確実に行う <br/>
POS38-C	fork およびファイル記述子を使用するときには競合状態に注意する <br/>
POS39-C	システム間でデータを送受信するときは正しいバイトオーダーを使用する <br/>
POS41-C	スレッドの終了状態が必要ない場合は pthread_detach() または同等の関数を使用する <br/>
POS44-C	シグナルを使ってスレッドを終了しない <br/>
POS47-C	非同期キャンセルが可能なスレッドを使用しない <br/>
POS48-C	他の POSIX スレッドのミューテックスをアンロックしたり破壊したりしない <br/>
POS49-C	データが複数のスレッドからアクセスされる場合、ミューテックスを使って隣接するデータがアクセスされないよう保護する <br/>

</div></details>

<details><summary>AA 参考情報</summary><div>

- [Bibliography](https://www.securecoding.cert.org/confluence/x/ngE) (CERT C Coding Standard のページにとびます)<br/>

- [『ソースコード解析ツールを活用した CERT セキュアコーディングルールの有効性評価』](https://www.jpcert.or.jp/research/2008/SecureCodingRules-J_200808.pdf) (PDF: 853KB)<br/>

</div></details>

<details><summary>BB Definitions</summary><div>

[Definitions](https://www.securecoding.cert.org/confluence/x/HgQ) (CERT C Coding Standard のページにとびます)<br/>

</div></details>

<details><summary>CC 未定義の動作</summary><div>

[Undefined Behavior](https://www.securecoding.cert.org/confluence/x/l4BjAg) (CERT C Coding Standard のページにとびます)

</div></details>

<details><summary>DD 未規定の動作</summary><div>

[Unspecified Behavior](https://www.securecoding.cert.org/confluence/x/WIHFAg) (CERT C Coding Standard のページにとびます)

</div></details>

