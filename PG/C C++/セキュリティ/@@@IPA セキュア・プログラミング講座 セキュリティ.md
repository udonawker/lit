[IPA セキュア・プログラミング講座](https://www.ipa.go.jp/security/awareness/vendor/programming/index.html "https://www.ipa.go.jp/security/awareness/vendor/programming/index.html")<br/>


## Ａ. WEBプログラマコース

## 共通編

### 第1章 Web
### 第2章 データベース
#### 2-1. SQL組み立て時の引数チェック
ユーザからの入力を埋め込んで検索のSQL文を組み立てるということはしばしば行われる。<br/>
このとき入力データのチェックが甘いと，ユーザは自分の都合の良いSQL 文を混入でき，データベースに干渉できるという問題が起こる。<br/>
#### 2-2. スクリプトに埋め込まれたDBパスワード
DBアプリケーションをスクリプト言語で記述することはよく行われることであるが，DBアカウントのパスワードをスクリプト内に埋め込んでいると，スクリプトのソースコードが漏洩したときに大きな問題になる。<br/>
#### 2-3. データベースとアクセス権
ＤＢアプリケーションが使用するアカウントにアクセス権限を与えすぎていると，バグを突かれてデータベースに被害が及ぶようなアクセスを許してしまうおそれがある。<br/>
<br/>

## 言語編
### 第3章 Java
#### 3-1. 危険なクラスたち
Javaのクラスライブラリには豊富な機能が揃っている。<br/>
規模の大きなソフトウェアを開発する際は，これらの強力な機能を乱用・誤用するコードが混入して，データの機密が損なわれたりシステムのコントロールが奪われたりしないよう注意する必要がある。<br/>
#### 3-2. カプセル化のすすめ
Javaをはじめとするオブジェクト指向プログラミング言語の基本的な特徴は，オブジェクトというカプセルの中に重要なデータを保管し，故意または過失により損なわれないようにする仕組みを持っていることである。<br/>
しかし意外とこの機能が活用されていない場合がある。<br/>
#### 3-3. シリアル化と情報漏洩
Javaのオブジェクトをファイルに保存したりネットワーク経由で送受信するときには「シリアル化」という手法が用いられる。<br/>
メモリ上のオブジェクトは無関係なクラスからのぞき見ることは出来ないが，シリアル化されたデータストリームを読むことは難しくない。<br/>
シリアル化されたデータから重要な情報が漏れないよう注意が必要である。<br/>
#### 3-4. クラス継承となりすまし
Javaのクラス継承にもとづくポリモーフィズム機能は強力なプログラミング手段を提供するものである。<br/>
しかし，それを逆手にとって既存のクラスとそっくりのふるまいをするが実は不正な情報操作も行うようなオブジェクトを混入することが可能である。<br/>
#### 3-5. Javaのアサーション
J2SE 1.4からJavaの新しい言語要素としてassertステートメントが導入された。<br/>
これはソフトウェアの正しさを確実にするための手法の一つ「アサーション」を記述するためのものである。<br/>
#### 3-6. synchronizedとレースコンディション
マルチスレッド処理で起こるレースコンディション問題は見つけにくいバグであり，セキュリティ脆弱性として潜在した場合大変やっかいである。<br/>
Javaプログラムではsynchronizedメソッドにより簡単にスレッド同期をはかることができる。<br/>
ただし，使い過ぎると性能が落ちることもあるので注意が必要だ。<br/>
<br/>

### 第4章 Perl
### 第5章 VBScript/ASP

## チェックリスト A.

## Ｂ. 製品プログラマコース

## 言語編

### 第6章 C/C++
#### 6-1. バッファオーバーラン　その１「こうして起こる」
データ領域あふれがスタック上で起こると大きなセキュリティ問題につながりかねない。<br/>
うまくスタックが書き換えられ，外部から送り込まれた不正なマシンコードが実行されてしまうことがあるからだ。<br/>
#### 6-2. バッファオーバーラン　その２「危険な関数たち」
C 言語および C++ 言語のライブラリ関数にはバッファオーバーランを引き起こしかねない関数が多数存在する。<br/>
ここでは，こうした関数を使わない方法，あるいはオーバーランの問題を防止しつつ使用する手法について解説する。<br/>
#### 6-3. 文字列処理の落とし穴
なんらかのエンコード形式で構成された文字列の解釈を行う際，そのフォーマットやルールを十分に把握しておかないと予期しない結果を生む恐れがある。<br/>
それが原因で不正なデータの通過を許してしまうことがあるからだ。<br/>
#### 6-4. サブシェル呼び出しは慎重に
system() 関数を使って他のコマンドを起動し処理を委ねる場合，そのコマンド文字列に予期せぬ他のコマンドが紛れ込まないよう厳重に入力検査を行うことが重要である。<br/>
また，起動するコマンドの参照をPATH環境変数に頼っていると，偽物のプログラムを起動させられ，システムを破壊されたり大切な情報を盗まれたりする恐れがある。<br/>
#### 6-5. メモリリーク
メモリリークとは，動的に割当てたメモリ領域を解放し忘れることで次第にメモリ資源を食いつぶしてゆき，いずれプログラムやシステムに異常をきたすという問題である。<br/>
メモリの解放し忘れは，エラー処理時などに本来とは異なるプログラム実行経路をとるときに起こりがちである。<br/>
#### 6-6. C++デストラクタによる安全な資源解放
メモリなどのリソースの動的確保と解放の仕組みに不整合があると，処理性能低下やプログラムの異常終了などの問題に見舞われる。単純なプログラムミスであることも多いが，このミスをゼロにすることは意外と難しい。<br/>
C++のデストラクタを利用してリソースの解放忘れを防ぐ手法を紹介する。<br/>
<br/>

## プラットフォーム

### 第7章 Unix/Linux

#### 7-1. シンボリックリンクの悪用
シンボリックリンクを用いてファイルが「すり替え」られていると，情報漏洩・破壊，業務妨害などが起こる。<br/>
重要なファイルにアクセスする際は，ファイルのすり替えが起こっていないことを十分確かめなければならない。<br/>
#### 7-2. PATH変数/子プロセスのすり替え
処理の一部分を別のプログラムを起動して任せる場合，子プロセスとして起動するプログラムが「すり替え」られていると，管理者権限が奪われたり，環境変数などから情報を盗まれる。<br/>
#### 7-3. setuidは慎重に
setuidは，プログラム実行時アカウントを一時的に変更することで一般ユーザが投入したコマンドの中で特殊な権限を必要とする処理の実行を可能にする機能である。<br/>
ところが，利用できる機能の限定の仕方が不十分だと，一般ユーザに大きな権限の使用を許してしまう問題が生じる。<br/>
#### 7-4. ネットワークサービスは必ずforkしよう
管理用のポートだからということで１つしか接続を受け付けないネットワークサービスがある。<br/>
このときプロセスを fork していないと，そのポートを占有されて業務妨害に陥ることがある。<br/>
#### 7-5. Unixのレースコンディション
シンボリックリンクによるファイルのすり替えが行われていないことを確認するような場合，単純にプログラミングしただけでは不正なプログラムにうまく割りこまれてしまうおそれがある。<br/>
ファイルシステムを検査する処理とファイルを確保する処理は合わせて一つの不可分な操作として実行できないからだ。<br/>
このような場合はもう一工夫しなくてはならない。<br/>
#### 7-6. coreファイルから情報が漏れる
Unix／Linux プロセスが異常終了すると core ファイルが生成される。<br/>
core ファイルは異常終了したプロセスのメモリイメージをそのまま保存したもので，デバッグや異常終了時の原因調査に役立つ。<br/>
しかし core ファイルが第三者から参照されると，メモリ上に存在するパスワードなどの機密情報が漏洩してしまう。<br/>
#### 7-7. Unixパス名の安全対策
相対パス記法を悪用したディレクトリトラバーサル攻撃から保護するために，パス名チェックは欠かせない。<br/>
しかし相対パス記法を仕様上認めるアプリケーションもある。<br/>
パス名を正規化して，意図するディレクトリ／ファイルを指しているかどうかをチェックしよう。<br/>
#### 7-8. テンポラリファイルから情報が漏れる
無権限者の干渉を受けやすい /tmp 上へのファイルの作成を避ける，シンボリックリンクによるすり替えを警戒するなど，Unix／Linuxシステムのアプリケーションでテンポラリファイルを取り扱うときの問題と安全な手法について説明する。<br/>
<br/>

### 第8章 Windows

#### 8-1. Windowsパス名の落とし穴
Windows の「パス名」は一筋縄ではいかない「くせ」を持っており，ユーザに入力させたパス名をプログラム中で使用するときは注意が必要である。<br/>
ディレクトリ区切り文字に「\」と「/」の両方が混在・重複しても許されたり，ロングネームとショートネームが存在するなど，複雑な事情がある。<br/>
#### 8-2. プロセス間通信とバックドア
プロセス間通信機能を活用して，システムに常駐するサービスプロセスとユーザインタフェースをもつクライアントプロセスの連携で処理を進めるというソフトウェアの形態がある。<br/>
サービスプロセスは通常高い権限で実行されるため，クライアントからの要求を無条件で受け入れて危険なシステム操作をしてしまわないよう，安全対策が必要である。<br/>
#### 8-3. NTFSのセキュリティ機能と落とし穴
Windowsプラットフォームでセキュリティを重視したシステムを構築する際にはファイルシステムとしてNTFSを採用することが不可欠である。<br/>
とくにアクセスコントロール機能は重要だ。<br/>
しかしNTFSには機能が多いために，ときとして思いがけない副作用に見舞われることもある。<br/>
<br/>

## 方法論編

### 第９章 セキュアな実装

#### 9-1. パスワードの取り扱い
ユーザ認証を行うアプリケーションが独自にアカウント情報を管理している場合がある。<br/>
しかし多くの場合，パスワードは平文で取り扱われ，データベースにも暗号化されずに保存されており，データが事故等で流出した場合に大きな問題となり得る。<br/>
#### 9-2. 入力値チェックの手法
入力値チェックを怠ると不正なコマンドを実行されてしまうなどのセキュリティ問題が生じる。<br/>
さまざまな経路からデータはプログラムへ入ってくるが，経路によらずすべてのデータを検査対象とすべきである。<br/>
排除すべきものを明示するより，受け入れられるものを明示する検査ポリシーが安全である。<br/>
#### 9-3. エラーメッセージからの情報の暴露
ユーザ入力の誤りについて詳細な情報を表示するのは親切な仕様であるといえる。<br/>
しかし，ログイン処理でそれを詳細に表示することはパスワード破りの手がかりを与えることにつながる。<br/>
また，ソフトウェアの内部構造を推定できるデバッグ情報がエラーメッセージに表示される可能性を見過ごしてしまうと危険である。<br/>
#### 9-4. 特権処理の局所化
機密情報やハードウェアを直接扱うプログラムは管理者権限など特別な権限「特権」で動作する必要がある。<br/>
万一セキュリティホールがあると，プログラムは悪用されシステム管理権限が奪われる。<br/>
こうしたプログラムでは特権処理を局所化し，またその他の処理では特権を放棄することで，セキュリティホールによる被害を最小限に抑える設計が必要だ。<br/>


### 第10章　より堅固なソフトウェア構築

#### 10-1. 設計段階からのセキュリティ
システム設計の過程で設けられてゆく各種の「インタフェース」や「通信経路」は，情報漏洩・改竄・業務妨害等の脅威を呼び込みかねないポイントとして要注意である。<br/>
そうした箇所の要所要所について事故や悪用を想定，対策を考案し，システム設計の改善をはかるべきである。<br/>
#### 10-2. 再利用と部品化
新しくソースコードを書くことは同時にバグとセキュリティ脆弱性が入る余地を作ることでもある。<br/>
もし検証済みで信頼できる既存のコードがあるならば，それを再利用したほうが高い信頼性を確保できる。<br/>
コードの再利用は問題を起こしにくいソフトウェアを構築する上で重要な手法の一つであるが，そのためには当初から部品化を考慮に入れた開発手法が欠かせない。<br/>
#### 10-3. モジュール分割は何度も練る
ソフトウェアを構成するモジュールをどのように分割するかは，そのソフトウェアに誤りが混入しやすいかどうかを左右する重要な設計要素である。<br/>
しかも，最初から理想的な分割設計ができることは少ない。<br/>
一度行った分割設計に対し，十分な練り直しが必要である。<br/>

## チェックリスト B.
