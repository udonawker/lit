# [C/C++ テンポラリファイル（Unix の一時ファイル）](https://www.ipa.go.jp/security/awareness/vendor/programmingv2/contents/c603.html)

## テンポラリファイル対策
* プログラム専用のテンポラリディレクトリを使う
* tmpnam() 等の脆弱性のある関数は使用しない
* 予測困難なファイル名にする
* 厳重なアクセス権を選定する
* シンボリックリンクをチェックする
* ファイルを作成したら unlink する

## プログラム専用のテンポラリディレクトリを使う
* プログラム専用のユーザを作成する
* プログラム専用のテンポラリディレクトリを作成する
* テンポラリのディレクトリは、プログラム専用のユーザのみがアクセス可能にする

## 使用を避けた方がよい関数
以下の3つの関数は、現在でも使用できるが、脆弱性があるため使用を避ける。<br>

* tmpnam(3), tempnam(3)
　既に存在するファイル、シンボリックリンクとの排他が取られない。<br>
* mktemp(3)
　生成するファイル名が推測可能である。<br>

その代わりに、以下に述べらている脆弱性が解消された `mkstemp(3)` 又は `tmpfile(3)` を使用するようにする。<br>

## 予測困難なファイル名にする
`mkstemp()` 関数や `tmpfile()` 関数を使うことで，安全で適切なテンポラリファイルの作成が可能である。これらの関数は以下の3つの注意点をすべて網羅している。<br>

* アクセス権限は自分のみに与える
* 同名のファイル（やシンボリックリンク）が存在しないことを確認する
* ランダムで予測困難なファイル名を生成する

### 1) int mkstemp(char *template);

mkstemp()関数はテンポラリファイルを作成，オープンし，ファイル記述子を返す。mkstemp()関数の引数には作成するテンポラリファイルのファイル名のテンプレートを渡す。テンプレートは<br>
<pre>
/tmp/my_tmp_file_XXXXXX
</pre>
といった文字列で，文字列の最後は6つの「X」で終わる必要がある。この「XXXXXX」部分が自動的にランダムな文字列に置き換えられ，ランダムな名前のテンポラリファイルが作成される。テンプレートに<br>
<pre>
/mydaemon_dir/tmp/prefix_XXXXXX
</pre>
といった文字列を与えると，デーモン専用のテンポラリファイルディレクトリ「/mydaemon_dir/tmp/」にテンポラリファイルを作成することもできる。<br>

#### 例　mkstemp() 使用
<pre>
char filepath[]    = "/tmp/my_file_XXXXXX";
                                    ↑6 文字の'X'が必要
fd = mkstemp(filepath);
filepath には、 'XXXXXX'が変換されて "/tmp/my_file_PvQLMk" のような文字列が返される。
</pre>

### 2) FILE *tmpfile(void);

tmpfile()関数はmkstemp()関数を使いやすくした位置付けのものである。具体的には次のような動作をする。<br>

* mkstemp()関数により/tmpディレクトリ下にテンポラリファイルを作成する
* unlink()システムコールによりファイル削除する
* fdopen()関数によりFILE*を取得する

## 厳重なアクセス権を選定する
テンポラリファイルのオープンは、本人のみが読み書きできるようにし、排他モードでオープンする。<br>
テンポラリファイルを open() により作成するのであれば、次の例のようにパラメータを指定する。<br>
<pre>
fd = open(path,  S_IRUSR | S_IWUSR, O_CREAT | O_RDWR | O_EXCL);

・S_IRUSR|S_IWUSR (=0600)
   S_IRUSR (=0400)        ユーザーに読み込みを許可する
   S_IWUSR (=0200)        ユーザーに書き込みを許可する

・mode = O_CREAT|O_RDWR|O_EXCL
   O_CREAT                ファイルが無ければ作成する
   O_RDWR                 読み書き用にオープンする
   O_EXCL                 ファイルが既に存在したらエラーとする
                          （O_CREATと合わせて使用する）
   O_CREAT|O_RDWR|O_EXCL  ファイルを作成オープンし，
                          すでに存在したらエラーとする
</pre>

## シンボリックリンクをチェックする
シンボリックリンク攻撃は、攻撃者が /tmp 等に読み書きするファイルを予測し、そのファイルが別なファイルを指すようにシンボリックリンクを張り、別なファイルにアクセスするように仕向けるものである。<br>
シンボリックリンク攻撃の対策については、本コンテンツの別記事 [「シンボリックリンク攻撃対策」](https://www.ipa.go.jp/security/awareness/vendor/programmingv2/contents/c802.html) を参照されたい。<br>

## ファイルを作成したら unlink する
テンポラリファイルを作成し、使用し終わったらクローズ close() し、削除 unlink()するのが一般的だが、テンポラリファイルを別なプログラムで使用しないのであれば、次のようにするとより安全になる。<br>
ファイルを作成 open() 直後に unlink() してしまう。unlink() してしもディレクトリから消えるのみで、ファイル自体にはアクセス可能であり、ファイル自体は存在し続けるが，どのディレクトリにも属さない状態となる。つまりファイル名が存在しなくなり、このファイルは二度と open() できなくなる。unlink() 以降はそのファイルへアクセスできるのは，unlink() 以前に open() したプロセスのみとなる。<br>
このように open() の直後に unlink() されたファイルは、プロセスが異常終了した時には、既に unlink(2) されているので残骸が残ることもなくなる。具体的には下記の例のようにする。<br>

#### 例
<pre>
#define TMPFILE "/tmp/my_tmp_file"

fd = open(TMPFILE, O_RDWR|O_CREAT|O_EXCL, S_IRUSR|S_IWUSR);
if(fd==-1) exit(1);

unlink(TMPFILE);

..... fd を使用して write() 等を行う
</pre>

## スティッキービット
過去のUnixシステムでは、所有者が root の /tmp のファイルを一般ユーザが削除できてしまっていた。現在のUnixシステムでは、ディレクトリの属性にスティッキービットを on にすることで、この問題を解決している。<br>
<pre>
drwxrwxrwt    5 root  root  4096 Dec  5 04:24 /tmp
         ↑
t:スティッキービット
</pre>

このビットが立っていると、以下のいずれかの条件に合致しないと、そのディレクトリ以下にあるファイルの削除権限が与えられない。<br>

* ファイルの所有者であること
* ディレクトリの所有者であること
* rootであること

## Windowsのテンポラリファイル
Windowsの場合、mkstemp() のような関数は Win32 APIには存在しない。Win32 API の GetTempPath() 関数により、テンポラリファイルのディレクトリを取得できるが、ランダムなファイル名を作成する APIは用意されていない。このため信頼性のある乱数等を使用して、ファイル名を作成する必要がある。<br>
※GetTempFileName() という関数があるが、これはファイル名の一意性を保障するのみで、推測困難なランダムなファイル名を作成するわけではない。<br>
<br>

----

# [安全な一時ファイルの作成と削除の方法 - 拡張 POSIX シェルスクリプト](https://fumiyas.github.io/2013/12/06/tempfile.sh-advent-calendar.html)

## 安全な一時ファイルの作成方法
<pre>
#!/bin/bash

tmpfile=/tmp/words.tmp
rm -f $tmpfile

echo 'しにたい' >>$tmpfile
echo 'とりあえずねよう' >>$tmpfile

sleep 3

echo -n '今どんな気持ち? '
read feeling
echo $feeling >>$tmpfile

cat $tmpfile
rm $tmpfile
</pre>
全然駄目ですね。 もし「何にも問題ないじゃないか!」という感想をお持ちの方は、 ぜひ悔い改めてください。<br>
肝心の「一時ファイルの作成」だけでも、次の問題があります。<br>

* このスクリプトを同時に起動したり、 同じパスのファイルを利用するほかのプロセスが同時に走ると競合が起きて、 ファイルが壊れる可能性がある。
* ファイルの中身を誰でも参照できる可能性がある。
* シンボリックリンク攻撃の脆弱性がある。
競合の問題は運用で回避すれば発生しないので、それでよければ無視できます。(酷い)<br>
ファイル内容漏洩の問題は、この例のように機密性のないどうでもいい内容であったり、 悪意ある者がローカルユーザーなどの参照する手段・権限を持たない、 かつほかの脆弱性を突かれてそれを奪取されたときのリスクを考慮しなくてよいのであれば、 無視できます。(これも酷い)<br>
シンボリックリンク攻撃の問題も、ファイル内容漏洩と同様です。 (一時ファイルの参照ではなく、同名のシンボリックリンクを作れるかどうかの問題)<br>
これらの問題の対処方法ですが、素人は黙って `mktemp(1)` を使ってください。 それだけで競合も内容漏洩もシンボリックリンク攻撃も避け、 安全にファイルを作成することができます。<br>

<pre>
#!/bin/bash

tmpfile=$(mktemp)

echo 'しにたい' >>$tmpfile
echo 'とりあえずねよう' >>$tmpfile

sleep 3

echo -n '今どんな気持ち? '
read feeling
echo $feeling >>$tmpfile

cat $tmpfile
rm $tmpfile
</pre>

`mktemp` は次のような仕様でファイルを作成します。<br>

* 既存のファイルを絶対に上書きしない。
    * 競合の回避。
    * シンボリックリンク攻撃の回避。
* 作成されるファイルのモードは必ず 0700 になる。
    * ファイル内容漏洩の回避。

## よくありがちなシェルスクリプトのダメ出し
* 各コマンドが失敗することを考慮していない。滅多に発生しないから無視ですか?
* `mktemp` が作成する一時ファイル名は `/tmp/tmp.<ランダム文字列>` と謎めいたものになり、何者が由来かわかりにくい。 トラブルシュート時などに厄介。
* `$feeling` に空白文字や `*` などパス名展開のパターン文字が入っていたらどうなるでしょうか? (zsh ならクォートなし変数展開後のワード分割もパス名展開もデフォルトではしないので問題なし)
* `read feeling` にも問題あるのだけど、これはまた別の機会に。

さらに修正してやります。<br>
<pre>
#!/bin/bash
# or
#!/bin/ksh
#!/bin/zsh

if [[ -n ${ZSH_VERSION-} ]]; then
  emulate -R ksh
  set -o BSD_ECHO
fi

set -e

tmpfile=$(mktemp "/tmp/${0##*/}.tmp.XXXXXX")

echo 'しにたい' >>"$tmpfile"
echo 'とりあえずねよう' >>"$tmpfile"

sleep 3

echo -n '今どんな気持ち? '
IFS= read -r feeling
echo "$feeling" >>"$tmpfile"

cat "$tmpfile"
rm "$tmpfile"
</pre>

簡単に解説します。<br>

* コマンド失敗時にそれを検知して即終了するために `set -e` を追加。 (この仕様でよいかは議論の余地あり)
* 一時ファイル名の識別がしやすいように `mktemp` に指定する一時ファイル名のテンプレートにスクリプト名を含める。
* `$feeling` を一時ファイルに出力するときにワード分割とパス名展開がされないようにダブルクォートで括った。 コーディングスタイルを統一するため、ほかの変数展開もダブルクォート括りに。
* `read` の問題も修正。こいつの解説はまた後日。
* ついでに zsh 対応も入れておきました。 ksh はそのままで大丈夫。
これで概ね問題のないシェルスクリプトになりました。

## 安全な一時ファイルの削除方法
残る問題が一つあります。<br>

* 最後の `rm` の前に終了したり殺されたときに一時ファイルが残ってしまう。
これは先日紹介した方法でスクリプト終了イベントとシグナルを捕捉 すればいいですね。<br>

<pre>
#!/bin/bash
# or
#!/bin/ksh
#!/bin/zsh

if [[ -n $ZSH_VERSION ]]; then
  emulate -R ksh
  set -o BSD_ECHO
fi

set -e

unset tmpfile

atexit() {
  [[ -n ${tmpfile-} ]] && rm -f "$tmpfile"
}

trap atexit EXIT
trap 'rc=$?; trap - EXIT; atexit; exit $?' INT PIPE TERM

tmpfile=$(mktemp "/tmp/${0##*/}.tmp.XXXXXX")

echo 'しにたい' >>"$tmpfile"
echo 'とりあえずねよう' >>"$tmpfile"

sleep 3

echo -n '今どんな気持ち? '
IFS= read -r feeling
echo "$feeling" >>"$tmpfile"

cat "$tmpfile"
</pre>
これで完成です。<br>

<br>

----
AIX など `mktemp` コマンドがない環境の場合は、 別途用意することをお勧めします。<br>
ちなみに `mktemp` 相当の機能はシェルだけでも実装可能です。 もし機会があれば、実装の紹介とともに、 どのようにして安全に一時ファイルを作成すればよいかを解説したいと思います。<br>
