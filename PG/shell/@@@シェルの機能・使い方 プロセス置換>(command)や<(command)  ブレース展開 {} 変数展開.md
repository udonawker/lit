# [シェルの機能・使い方で覚えとくこと(主にbash)](https://orebibou.com/ja/documents/shellgei/)
## リダイレクト
ファイルへの書き込みや読み込みを指定できる。<br>
### 書き込み処理の書き方
基本的にこれだけ覚えてれば通常のコンソール操作では困らない気もする。 設定内容をファイルに書いたり、出力結果を適当なファイルに追記したりと色々なトコで使うと思う。<br>
```
# 書き込み(上書き)
comamnd > file_path

# 書き込み(追記)
comamnd >> file_path

# 出力元のファイルディスクリプタ(FD)を指定
command 1> file_path # 標準出力のみをリダイレクト(デフォルト)
command 2> file_path # 標準エラー出力のみをリダイレクト
command &> file_path # 標準出力・標準エラー出力を共にリダイレクト

# 標準出力/標準エラー出力を入れ替える
command 3>&1 1>&2 2>&3
```

### 読み込み処理の書き方
ファイルの読み込みも行える。<br>
```
# ファイルを読み込む
command < file_path

# `EOF`(文字列は指定可能)の行が出るまでを読み込む
# (Tabなどを受け付ける場合は`<<`ではなく`<<-`を使う)
command << EOF
111
222
333
EOF

# 文字列を標準入力で受け付ける(パイプと同様)
command <<< string
```

## プロセス置換
`>(command)`や`<(command)`といった書き方で、本来はファイルを指定する引数に実行コマンドを指定することができる。<br>
少しわかりにくいのだが、使えるとかなり便利。 かんたんな例として、sortしていないファイルのdiff(diffコマンドは事前にファイルをsortしておく必要がある)を書いておく。<br>

## ブレース展開
個人的に好きな機能。 `{...}`といった感じで記述することで、シェルがコマンド実行前に内容を解釈して展開してくれる。
基本的にはカンマ(,)区切りで指定した要素を展開するのだが、連続した要素(数字やアルファベットなど)であれば `{a..z}` といった感じで記述することができる。
```
$ # カンマ区切りで展開させる
$ echo {aaa,bbb,ccc,ddd,123}
aaa bbb ccc ddd 123
$
$ # 前後に文字を記述することで展開する要素にも適用する
$ echo x_{111,222,333,444}
x_111 x_222 x_333 x_444
$
$ # ブレース展開はネストすることも可能
$ echo x_{1{2,3,4},3}
x_12 x_13 x_14 x_3
$
$ # 複数のブレース展開を結合して記述することで、それぞれの組み合わせを取得できる
$ echo {a..c}_{1..3}
a_1 a_2 a_3 b_1 b_2 b_3 c_1 c_2 c_3
$
$ # 連続する要素は`..`で指定できる
$ echo {0..9}
0 1 2 3 4 5 6 7 8 9
$ echo {a..e}
a b c d e
$
$ # 連続する要素の間隔も指定できる
$ echo {0..9..3}
0 3 6 9
```

## 三項演算子
他の言語でもある三項演算子っぽい記述方法。 `&&`のあとに前のコマンドが正常終了時の処理を、`||`のあとに異常終了時の処理を続けて記述できる。<br>
```
command1 ... && command1正常終了時の処理 || command1異常終了時の処理
```
```
$ # 正常終了時に`echo 0`
$ echo test && echo 0 || echo 1
test
0
$
$ # 異常終了時に`echo 1` (コマンド実行時に!を頭につけると終了ステータスを反転できる)
$ ! echo test && echo 0 || echo 1
test
1
```

## グルーピング
コマンドを`(...)`や`{...}`で囲むことで、ひとまとめのグループとして扱う。 リダイレクトの際にひとかたまりのコマンドとして扱わせたりすることができる。<br>
```
# command1,command2の出力をまとめてcommand3にわたす
( command1;command2; ) | command3
{ command1;command2; } | command3
```

## Glob展開
`*(アスタリスク)`で、PATHをワイルドカード検索する機能。 echoなどでも展開が行われる。
コマンド実行前に解釈されるので、もし`*`を引数に入れる場合は`\`でエスケープするかクォーテーションで囲んでやる必要がある。

## 変数展開
bashの機能として、変数展開時の記述の仕方で、変数の値を置換や抜き出すことができる。<br>
```
$ TEST=123456789
$ echo ${TEST}
123456789
$
$ # 変数の文字数を取得
$ echo ${#TEST}
9
$
$ # 後ろから3文字抜き出す
$ echo ${TEST: -3}
789
$
$ # 後ろから3文字消す
$ echo ${TEST::-3}
123456
```

|パラメータ展開|機能|
|-|-|
|${#変数}|変数の文字数を取得する|
|${変数:-文字列}|変数がNULLの場合、指定した文字列を返す|
|${変数:+文字列}|変数がNULL以外の場合、指定した文字列を返す|
|${変数:=文字列}|変数がNULLの場合、変数に指定した文字列を代入する|
|${変数:?文字列}|変数がNULLの場合、指定した文字列を返しエラー終了する|
|${変数#文字列}|変数より、前方から最短一致した箇所を除外する(基本ワイルドカード組み合わせ要)|
|${変数##文字列}|変数より、前方から最長一致した箇所を除外する(基本ワイルドカード組み合わせ要)|
|${変数%文字列}|変数より、後方から最短一致した箇所を除外する(基本ワイルドカード組み合わせ要)|
|${変数%%文字列}|変数より、後方から最長一致した箇所を除外する(基本ワイルドカード組み合わせ要)|
|${変数:N}|変数より、N文字以降の文字のみ抽出する|
|${変数:N:X}|変数より、N文字目からX個の文字を抽出する|
|${変数: -N}|変数より、後ろからN文字のみ抽出する|
|${変数: -N:X}|変数より、後ろからN文字、X個の文字のみ抽出する|
|${変数::N}|変数より、頭からN文字のみ抽出する|
|${変数::-N}|変数より、後ろからN文字除外する|
|${変数/置換前/置換後}|変数の内容を、置換前文字列を置換後文字列に変換して返す|
|${変数^[文字列]}|変数の一文字目を大文字にする(文字列を指定してる場合はその文字列のみを対象にする)|
|${変数^^[文字列]}|変数全体を大文字にする(文字列を指定してる場合はその文字列のみを対象にする)|
|${変数,[文字列]}|変数の一文字目を小文字にする(文字列を指定してる場合はその文字列のみを対象にする)|
|${変数,,[文字列]}|変数全体を小文字にする(文字列を指定してる場合はその文字列のみを対象にする)|
|${!文字列*}|指定された文字列から始まる変数を取得する|

## 算術式展開
bashでは、`$((...))`といった記述をすることで、中の式の計算結果を出力して利用できる。 ただ、小数点以下の計算はできないので注意。<br>
```
$ # 基本的な四則演算ができる
$ echo $((1+2))
3
$ echo $((1+2*3))
7
$
$ # 乗数は`**`で計算する
$ echo $((2**3))
8
```
