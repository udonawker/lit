## [diffでコマンドの出力の結果を直接比較する。](https://qiita.com/wingedtw/items/2f05c5d0c37d71f209f4)

```
diff <(ls dir1) <(ls dir2)
```


---
---
---

## コマンドの結果を比較したい時ってあるよね！
たとえば、dir1とdir2のファイル構成を比較したいとき。<br>

## 実直な方法。
```
$ ls dir1 > file_list.dir1.txt
$ ls dir2 > file_list.dir2.txt
$ diff file_list.dir1.txt file_list.dir2.txt
```

中間ファイルを作る方法です。<br>
多分一番スタンダードですが、私はあまり中間ファイル残したくない人なので・・・。<br>

## コマンドの結果を直接食う！！
コマンドの結果を次のコマンドに渡す手っ取り早い方法、それはパイプ！<br>
でも1つしか使えないし、そもそもdiffはパイプの食わせ方がありません。<br>

コマンドによっては - を指定すると標準入力から入力を待つのもありますが。<br>
私が良く使う例。<br>

```
ssh.sh
tar czf - * | ssh hoge@fuga.com "tar xzf -"
```

とか。<br>
ネットの帯域が狭かったころに、圧縮してファイルを転送する方法です。<br>

## パイプに結果を流す。
名前付きパイプと言うのがあるのですが、それの説明はまたそのうち。<br>
結論から書くと、<br>

```
diff <(ls dir1) <(ls dir2)
```

となります。<br>
<(...) はコマンドの結果を(名前付き)パイプに放り込む方法で、名前付きパイプはファイルと同等の扱いをされます。<br>
この結果、ls dir1の結果　と　ls dir2の結果　が名前付きパイプとしてファイル扱いされ、diffによって比較されることとなります。<br>

## そんなに使うのかい・・・？
この　<(...)　って結構使えてですね。<br>
ファイルしか入力に対応してないものとか、標準入力からの入力に対応してるけど複数食わせたいときとかに重宝します。<br>

たとえばー。<br>

```
cat <(grep -E "^hoge" file) <(grep -vE "^hoge" file) > hoge_head.txt
```

とかやって、hogeから始まる行だけを先頭にまとめるとか。<br>
何か良い例が思いつきません！<br>
